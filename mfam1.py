# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MFAM_Loader
                                 A QGIS plugin
 This plugin will load MFAM data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-09-11
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Acme
        email                : Jack@home
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#from qgis.core import QgsProject,  QgsVectorLayer,  QgsFeature,  QgsField,  QgsGeometry,  QgsPointXY
from qgis.core import *
from math import cos, sin, asin, sqrt, radians
from PyQt5.QtCore import QVariant
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QFileDialog
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .mfam1_dockwidget import MFAM_LoaderDockWidget
import os.path


class MFAM_Loader:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MFAM_Loader_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&mfam_loader')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'MFAM_Loader')
        self.toolbar.setObjectName(u'MFAM_Loader')

        #print "** INITIALIZING MFAM_Loader"

        self.pluginIsActive = False
        self.dockwidget = None

    def DecDegrees(self,  coord):                            # Subroutine to convert DDMM.mm to DD.dddd
        decimal = coord.find(".") - 2                        # Given an input DDMM.mm, this provides the position between DD and MM
        dec_degrees = float(coord[:decimal]) + float(coord[decimal:]) / 60
        return dec_degrees
        
    def TotalSeconds(self, time_stamp):                      # Two ways of indicating time in these files; this makes them the same
        if len(time_stamp.split(":")) > 1:
            seconds = float(time_stamp.split(":")[0]) * 3600 + float(time_stamp.split(":")[1]) * 60 + float(time_stamp.split(":")[2]) 
        else:
            seconds = float(time_stamp[0:2]) * 3600 + float(time_stamp[2:4]) * 60 + float(time_stamp[4:]) 
        return(seconds)

    def CalcDistance(self, lat1, lon1, lat2, lon2):
        """
        Calculate the great circle distance between two points
        on the earth (specified in decimal degrees)
        https://gis.stackexchange.com/questions/61924/python-gdal-degrees-to-meters-without-reprojecting
        """
        # convert decimal degrees to radians
        lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
        # haversine formula
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2
        c = 2 * asin(sqrt(a))
        km = 6371 * c
        return km

    def add_to_file_list(self):
        filenames = QFileDialog.getOpenFileNames(self.dockwidget, 'Open MFAM Data File', '', 'MFAM Files (*.dat *.txt *.asc)')
        filenames = filenames[0]                             # Trim off file type information
        print(filenames)                                     # For debugging (use console)

        self.dockwidget.listWidget.show()
        #self.ProcessFile(filenames)

        for item in range(0, len(filenames)):
            self.dockwidget.listWidget.addItem(filenames[item])

    def selectOutputFile(self):
        if self.dockwidget.outputCheckBox.isChecked():
            outputfile = QFileDialog.getSaveFileName(self.dockwidget, 'Save MFAM Output As:', '', 'MFAM Files (*.txt)')
            self.dockwidget.outputFileName.setFilePath(outputfile[0])

    def tr(self, message):
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MFAM_Loader', message)

    def clearList(self):
        self.dockwidget.listWidget.clear()

    def processDrone(self):
        #drive, path = os.path.splitdrive(filename)
        #path, filehandle = os.path.split(path)
        vl = QgsVectorLayer("Point","bundle", "memory")      # Initiate a virtual GIS layer
        QgsProject.instance().addMapLayer(vl)                # currentProject.addMapLayer(vl)
        vl.startEditing()
        pr = vl.dataProvider()

        # Add field to virtual layer 
        pr.addAttributes( [ QgsField("TGM", QVariant.Int),
                QgsField("Fiducial",  QVariant.Int),
                QgsField("FrameID",  QVariant.Int), 
                QgsField("SysStat",  QVariant.Int),
                QgsField("Mag1D",  QVariant.Double),
                QgsField("Mag1S",  QVariant.Int),
                QgsField("Mag2D",  QVariant.Double),
                QgsField("Mag2S",  QVariant.Int),
                QgsField("V1",  QVariant.Int),
                QgsField("V2",  QVariant.Int),
                QgsField("V3",  QVariant.Int), 
                QgsField("V4",  QVariant.Int), 
                QgsField("Time_UTC",  QVariant.Int),
                QgsField("Latitude",  QVariant.Double), 
                QgsField("Longitude",  QVariant.Double),
                QgsField("FixQuality",  QVariant.Int),
                QgsField("NumSats",  QVariant.Int),
                QgsField("HDOP",  QVariant.Double),
                QgsField("Altitude",  QVariant.Double),
                QgsField("GeoidHt",  QVariant.Double),
                QgsField("Validity",  QVariant.String),
                QgsField("CMG",  QVariant.Double), 
                QgsField("Date",  QVariant.Int), 
                QgsField("FileName",  QVariant.String) ] )
        vl.updateFields()

        for item in range(self.dockwidget.listWidget.count()):                            # Begin iteration through all files

            infile = open(self.dockwidget.listWidget.item(item).text(),"r")               # Opens file, count line entries
            with infile:
                for line_count, l in enumerate(infile):
                    pass
    
            infile = open(self.dockwidget.listWidget.item(item).text(),"r")               # Set up input and output files
            invalid_lines = 0
            target_address = []
            GPGGA = []
            GPRMC = []

            # Get PPS addresses, GPGGA and GPRMC
            for line in range(1,(line_count+2)):
                data_line = infile.readline()
                data_array = data_line.strip("\n").split(", ")
                if data_array[0] == "PPS: 0":
                    target_address.append(data_array[1])
                if len(data_line.strip("\n").split("$")) > 1:
                    if data_line.strip("\n").split("$")[1].split(",")[0] == "GPGGA":
                        GPGGA.append(data_line.strip("\n").split("$")[1].split(","))
                    elif data_line.strip("\n").split("$")[1].split(",")[0] == "GPRMC":
                        GPRMC.append(data_line.strip("\n").split("$")[1].split(","))  
    
            infile = open(self.dockwidget.listWidget.item(item).text(),"r") 
            for line in range(1,(line_count+2)):              # Iterate through each line, looking for PPS match
                data_line = infile.readline()
                data_array = data_line.strip("\n").split(",")
                results = []
    
                try:                                          # Use the try statement, looking for PPS match
                    for a in range(0,12):                    # first 12 columns are unaltered
                        results.append(float(data_array[a]))
                except:
                    print("Invalid line at %d, total invalid lines: %d" % (line, invalid_lines))
                    invalid_lines = invalid_lines + 1
    
                try:
                    if (data_array[0] in target_address):    # Check if TGM is in PPS target list
                        GPGGA_array = GPGGA[target_address.index(data_array[0])]
                        GPRMC_array = GPRMC[target_address.index(data_array[0])]
                        lat = float(self.DecDegrees(GPGGA_array[2]))
                        if (GPGGA_array[5] == 'W'):
                            long = -(float(self.DecDegrees(GPGGA_array[4])))
                        else:
                            long = float(self.DecDegrees(GPGGA_array[4]))
                        #self.dockwidget.listWidget.addItem('LatLong: ' + '%3.6f' %lat + ', ' + '%3.6f' %long)

                        feat = QgsFeature()                  # Vector layer feature added
                        feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(long, lat)))
                        feat.setAttributes([ int(data_array[0]), int(data_array[1]), int(data_array[2]), int(data_array[3]), float(data_array[4]), 
                            int(data_array[5]), float(data_array[6]), int(data_array[7]), int(data_array[8]), int(data_array[9]), int(data_array[10]),  int(data_array[11]), 
                            int(float(GPGGA_array[1])),  lat,  long, int(GPGGA_array[6]), int(GPGGA_array[7]), 
                            float(GPGGA_array[8]), float(GPGGA_array[9]),  float(GPGGA_array[11]),  str(GPRMC_array[2]), float(GPRMC_array[8]),  int(GPRMC_array[9]),  self.dockwidget.listWidget.item(item).text() ])

                        vl.addFeature(feat)
                        vl.updateExtents()
    
                except:
                    #self.dockwidget.listWidget.addItem(data_array[0])
                    print("Did not write GPGGA/GPRMC data to file at line %d" % line)

            infile.close()
        vl.commitChanges()
        #vl.loadNamedStyle('Spectrum.qml')
        #vl.triggerRepaint()
        #iface.layerTreeView().refreshLayerSymbology(layer.id())

    def processMag(self):

        vl = QgsVectorLayer("Point","bundle", "memory")  # Initiate a virtual GIS layer
        QgsProject.instance().addMapLayer(vl)  #currentProject.addMapLayer(vl)
        vl.startEditing()
        pr = vl.dataProvider()
        if self.dockwidget.outputCheckBox.isChecked():
            outfile = open(self.dockwidget.outputFileName.filePath(),"w")

        # Add field to virtual layer 
        pr.addAttributes( [ QgsField("Time_UTC",  QVariant.Int),
                QgsField("Validity",  QVariant.String),
                QgsField("Latitude",  QVariant.Double), 
                QgsField("N",  QVariant.String),
                QgsField("Longitude",  QVariant.Double),
                QgsField("W",  QVariant.String),
                QgsField("Altitude",  QVariant.Double),
                QgsField("Velocity",  QVariant.Double),
                QgsField("Heading",  QVariant.Double),
                QgsField("Mag1D",  QVariant.Double),
                QgsField("Mag2D",  QVariant.Double),
                QgsField("Fiducial",  QVariant.Int), 
                QgsField("GyroX",  QVariant.Double),
                QgsField("GyroY",  QVariant.Double),
                QgsField("GyroZ",  QVariant.Double),
                QgsField("GyroT",  QVariant.Double),
                QgsField("AccelX",  QVariant.Double),
                QgsField("AccelY",  QVariant.Double),
                QgsField("AccelZ",  QVariant.Double),
                QgsField("AccelT",  QVariant.Double),
                QgsField("CompassX",  QVariant.Double),
                QgsField("CompassY",  QVariant.Double),
                QgsField("CompassZ",  QVariant.Double),
                QgsField("CompassT",  QVariant.Double),
                QgsField("CompassX",  QVariant.Double),
                QgsField("Date",  QVariant.String),
                QgsField("FileName",  QVariant.String)  ] )
        vl.updateFields()

        for item in range(self.dockwidget.listWidget.count()):                         # Begin iteration through all files

            infile = open(self.dockwidget.listWidget.item(item).text(),"r")            # Opens file, count line entries
            with infile:
                for line_count, l in enumerate(infile):
                    pass

            infile = open(self.dockwidget.listWidget.item(item).text(),"r")            # Work out the sampling rate
            data_line = infile.readline()
            time1 = self.TotalSeconds(data_line.split(",")[19])
            data_line = infile.readline()
            time2 = self.TotalSeconds(data_line.split(",")[19])
            delta_sec = time2 - time1
            sample_rate = 1 / delta_sec                  # Sampling rate, in Hz
            self.dockwidget.sampleRateSpin.setValue(round(sample_rate))

            infile = open(self.dockwidget.listWidget.item(item).text(),"r") 
            GPRMC = []
            data_line = infile.readline()
            for line in range(0,(line_count-1)):
                data_line = infile.readline()
                if data_line.strip("\n").split(",")[21] == "$GPRMC":
                    info = data_line.strip("\n").split(",")[22:]
                    info.insert(0,data_line.strip("\n").split(",")[2])
                    GPRMC.append(info)                        #Array is 13 elements long, with file line number in the first position

            infile = open(self.dockwidget.listWidget.item(item).text(),"r") 
            data_line = infile.readline()
            fid_old = int(data_line.split(",")[2])
            fid_new = fid_old + 1
            while (fid_new > fid_old):
                data_line = infile.readline()             # scroll to the first valid start of the next '0' in the ms cycle
                fid_new = int(data_line.split(",")[2])
                fid_old = fid_new

            if int(self.TotalSeconds(GPRMC[0][1])  < self.TotalSeconds(data_line.split(",")[19])):   # If this is True, this means there is no corresponding GPS info for the first lines of the file, so discard          
                GPRMC = GPRMC[1:]                             # remove that first useless GPRMC

            data_elements = ([0,1,2,6,7,8,9,10,11,12,13,14,15,16,17])              # Indices, on each line, of the desired dataset
            data_array = []
            data_old = data_line
            lat = float(self.DecDegrees(GPRMC[0][3]))
            if (GPRMC[0][6] == 'W'):
                long = -(float(self.DecDegrees(GPRMC[0][5])))
            else:
                long = float(self.DecDegrees(GPRMC[0][5]))

            for cycle in range(1,len(GPRMC)-1):                # Start hunting for 1000 rollover point
                while (self.TotalSeconds(data_old.split(",")[19]) < (self.TotalSeconds(GPRMC[cycle][1]) ) ):         # i.e. as long as sequence is ascending, continue..
                    if self.dockwidget.outputCheckBox.isChecked():       # Write output file, if box is checked
                        info = data_line.strip("\n").split(",")
                        T_orig = self.TotalSeconds(GPRMC[cycle-1][1])     # Interpolate time interval
                        T_current = self.TotalSeconds(info[19])
                        T_next = self.TotalSeconds(GPRMC[cycle][1])
                        weighting = ( T_current - T_orig ) / ( T_next - T_orig )
                        
                        lat = float(self.DecDegrees(GPRMC[cycle-1][3]))
                        long = float(self.DecDegrees(GPRMC[cycle-1][5]))
                        
                        lat_delta = float(self.DecDegrees(GPRMC[cycle][3])) - lat
                        long_delta = float(self.DecDegrees(GPRMC[cycle][5])) - long
                            
                        outfile.write('%.3f, %d, %.3f, %.3f, %.10f, %.9f, %.2f, %s, %s, %.4f, %.4f, %.2f, %.2f, %.2f, %.1f, %.5f, %.5f, %.5f, %.1f, %.5f, %.5f, %.5f, %.1f\n' %
                            (float(GPRMC[cycle-1][1]),   # Time (UTC)
                            int(info[2]),   # Fiducial
                            float(weighting), 
                            float(T_current), 
                            float(lat + lat_delta * weighting),    # Lattitude
                            float(long + long_delta * weighting),    # Lattitude
                            float(info[7]),    # Altitude
                            str(info[18]),    # Date
                            str(info[19]),    # Time
                            float(info[0]),    # Mag 1D
                            float(info[1]),    # Mag 2D 
                            float(info[6]),    # GyroX
                            float(info[7]),    # GyroY
                            float(info[8]),    # GyroZ
                            float(info[9]),    # GyroT
                            float(info[10]),    # AccelX
                            float(info[11]),    # AccelY
                            float(info[12]),    # AceelZ
                            float(info[13]),    # AccelT
                            float(info[14]),    # CompassX
                            float(info[15]),    # CompassY
                            float(info[16]),    # CompassZ
                            float(info[17])     # CompassT
                            ))
                    data_line = infile.readline()
                    data_old = data_line

                lat_old = lat
                long_old = long
                T_orig = self.TotalSeconds(GPRMC[cycle][1])     # Interpolate time interval
                T_current = self.TotalSeconds(data_line.strip("\n").split(",")[19])
                T_next = self.TotalSeconds(GPRMC[cycle+1][1])
                weighting = ( T_current - T_orig ) / (( T_next - T_orig ) * 1000)
                data_entry = GPRMC[cycle]

                for a in data_elements:                      # Pick out the desired items from the data line, weighted according to the interpolation of time data
                    delta_item = (float(data_line.split(",")[a].strip(" ")) - float(data_old.split(",")[a].strip(" "))) * weighting    # this is the interpolation of each value
                    data_entry.append(float(data_old.split(",")[a].strip(" ")) + delta_item)

                data_array.append(data_entry)
                lat = float(self.DecDegrees(data_entry[3]))
                if (data_entry[6] == 'W'):
                    long = -(float(self.DecDegrees(data_entry[5])))
                else:
                    long = float(self.DecDegrees(data_entry[5]))
                print('lat: %.3f,  long: %.3f,  lat_old: %.3f,  long_old: %.3f' %(lat, long, lat_old, long_old))
                velocity = self.CalcDistance(lat_old, long_old, lat, long)/( T_next - T_orig )

                try:
                    feat = QgsFeature()                      # Vector layer feature added
                    feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(long, lat)))
                    feat.setAttributes([ float(data_entry[1]),   # Time UTC
                        str(data_entry[2]),      # Validity
                        lat,                     # Latitude
                        str(data_entry[4]),      # "N"
                        long,                    # Longitude
                        str(data_entry[6]),      # "W"
                        float(data_entry[7]),    # Velocity1
                        velocity,                       # Velocity2
                        float(data_entry[8]),    # Heading
                        float(data_entry[13]),   # Mag 1D
                        float(data_entry[14]),   # Mag 2D
                        int(data_entry[15]),     # Fiducial
                        float(data_entry[16]),   # GyroX
                        float(data_entry[17]),   # GyroY
                        float(data_entry[18]),   # GyroZ
                        float(data_entry[19]),   # GyroT
                        float(data_entry[20]),   # AccelX
                        float(data_entry[21]),   # AccelY
                        float(data_entry[22]),   # AccelZ
                        float(data_entry[23]),   # AccelT
                        float(data_entry[24]),   # CompassX 
                        float(data_entry[25]),   # CompassY 
                        float(data_entry[26]),   # CompassZ 
                        float(data_entry[27]),   # CompassT 
                        int(data_entry[9]),      # Date
                        self.dockwidget.listWidget.item(item).text() ])

                    vl.addFeature(feat)
                    vl.updateExtents()

                except:
                    #self.dockwidget.listWidget.addItem(data_array[0])
                    print("Did not write feature to shape at line %d" % line)

            infile.close()

        if self.dockwidget.outputCheckBox.isChecked():
            outfile.close()
        vl.commitChanges()

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/mfam1/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MFAM Loader'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------
    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING MFAM_Loader"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD MFAM_Loader"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&mfam_loader'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------


    def branch(self):
        if self.dockwidget.Drone_button.isChecked():
            self.processDrone()
        else:
            self.processMag()


    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING MFAM_Loader"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = MFAM_LoaderDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)

            self.dockwidget.show()
            self.dockwidget.load_files.clicked.connect(self.add_to_file_list)
            self.dockwidget.outputCheckBox.stateChanged.connect(self.selectOutputFile)
            self.dockwidget.clear_List.clicked.connect(self.clearList)
            self.dockwidget.process_files.clicked.connect(self.branch)

